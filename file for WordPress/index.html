<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>×¤×™×œ×˜×¨ ×¦×‘×¢×™ ×¢×™× ×™×™× (××¡×•××Ÿ) â€“ blink gating</title>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>

<style>
  #eye-filter-widget * {
  box-sizing: border-box;
}


#eye-filter-widget {
  justify-items: center;
  margin: 16px auto;
  padding: 0 8px;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,
               Oxygen, Ubuntu, Cantarell, sans-serif;
}


/* Card container */
.efw-card {
  border: 1px solid #e5e7eb;
  border-radius: 16px;
  padding: 20px;
  box-shadow: 0 4px 24px rgba(0, 0, 0, 0.1);
  background: #fff;
  direction: rtl;
}

@media (max-width: 480px) {
  .efw-card {
    padding: 12px;
  }
}

.efw-row {
  display: flex;
  flex-direction: column;
  gap: 20px;
  align-items: center;
}

/* @ here is where you can change the size of the window with: aspect-ratio */
/* Camera window */
.efw-video-wrap {
  position: relative;
  width: 670px;
  height: 700px;                
  aspect-ratio: 9 / 16; 
  background: linear-gradient(135deg, #1e293b, #334155);
  border-radius: 12px;
  overflow: hidden;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
}

@media (max-width: 720px) {
  .efw-video-wrap {
    max-width: 95vw;
    }
}


#efw-canvas {
  width: 100%;
  height: 100%;
  display: block;
  border-radius: 12px;
  object-fit: cover;
  transform: scaleX(-1);
}

video#efw-video {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  object-fit: contain;
  opacity: 0;
  pointer-events: none;

  
}

/* Text and layout */
.efw-label {
  display: block;
  font-size: 14px;
  margin-bottom: 8px;
  font-weight: 600;
}

.efw-inline {
  display: flex;
  gap: 10px;
  align-items: center;
  justify-content: center;
  flex-wrap: wrap;
}

.efw-brightness-control{
  display: flex;
  flex-direction: column;
  gap: 10px;
  width: 50%;
  align-items: center;
  justify-self: center;
  margin: 12px 0;
  border-radius: 10px;
}

/* Select dropdown styling */
select.efw-inline {
  padding: 10px 12px;
  border: 2px solid #ccc;
  border-radius: 6px;
  background: #fff;
  color: #333;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
  min-width: 180px;
  appearance: none;
  background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
  background-repeat: no-repeat;
  background-position: right 10px center;
  background-size: 20px;
  padding-right: 36px;
}

select.efw-inline:hover {
  border-color: #999;
  background-color: #f9f9f9;
}

select.efw-inline:focus {
  outline: none;
  border-color: #0ea5e9;
  box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.1);
}

select.efw-inline option {
  padding: 10px;
  background: #fff;
  color: #333;
}

/* Chips (round selection buttons) */
.efw-chip {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  height: 34px;
  min-width: 96px;
  padding: 0 14px;
  border-radius: 9999px;
  border: 2px solid #cbd5e1;
  cursor: pointer;
  transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  white-space: nowrap;
  font-size: 12px;
  font-weight: 700;
  line-height: 1;
  color: #fff;
  text-shadow: 0 1px 1px rgba(0, 0, 0, 0.35);
}
.efw-chip::after {
  content: attr(title);
}
.efw-chip:hover {
  transform: scale(1.04);
  border-color: #475569;
}
.efw-chip.active {
  border-color: #0ea5e9;
  box-shadow: 0 0 0 2px rgba(14, 165, 233, 0.2);
}

/* .efw-chip-none{
  background: transparent;
  border: 2px solid rgba(255,255,255,.75);
  position: relative;
}
.efw-chip-none::after{
  content: "";
  position: absolute;
  inset: 3px;
  border-radius: 999px;
  border: 2px solid rgba(255,255,255,.75);
  transform: rotate(45deg);
  clip-path: polygon(0 45%,100% 45%,100% 55%,0 55%);
} */

/* Buttons */
.efw-btn {
  appearance: none;
  border: 1px solid #0f172a;
  background: #0f172a;
  color: #fff;
  padding: 12px 16px;
  border-radius: 10px;
  cursor: pointer;
  font-weight: 600;
  transition: all 0.2s ease;
  font-size: 14px;
}
.efw-btn:hover {
  background: #1e293b;
  transform: translateY(-1px);
}
.efw-btn.sec {
  background: #fff;
  color: #0f172a;
  border-color: #cbd5e1;
}
.efw-btn.sec:hover {
  background: #f1f5f9;
}
.efw-btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
  transform: none;
}

.efw-small {
  font-size: 12px;
  color: #64748b;
  line-height: 1.4;
}

.efw-status-bad {
  color: #dc2626;
  font-weight: 600;
}
.efw-status-ok {
  color: #059669;
  font-weight: 600;
}

.efw-intensity-btn {
  flex: 1;
  padding: 10px 16px;
  border: 2px solid #ccc;
  border-radius: 6px;
  background: #fff;
  cursor: pointer;
  font-size: 14px;
  font-weight: 500;
  transition: all 0.2s;
}

.efw-intensity-btn:hover {
  border-color: #999;
}

.efw-intensity-btn.active {
  background: #333;
  color: #fff;
  border-color: #333;
}

.efw-status {
  margin-top: 12px;
  min-height: 24px;
  white-space: pre-line;
  padding: 8px;
  background: #f8fafc;
  border-radius: 8px;
  border: 1px solid #e2e8f0;
}

.efw-color-input {
  width: 40px;
  height: 40px;
  border: none;
  border-radius: 8px;
  cursor: pointer;
}

/* Loading animation */
.loading-dot {
  display: inline-block;
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: #0ea5e9;
  margin: 0 2px;
  animation: loading 1.4s infinite ease-in-out both;
}
.loading-dot:nth-child(1) {
  animation-delay: -0.32s;
}
.loading-dot:nth-child(2) {
  animation-delay: -0.16s;
}
@keyframes loading {
  0%, 80%, 100% {
    transform: scale(0);
  }
  40% {
    transform: scale(1);
  }
}

/* Static logo above the camera window */
.efw-logo {
  position: absolute;
  z-index: 3;
  top: 8px;
  left: 50%;
  transform: translateX(-50%);
  padding: 6px 12px;
  border-radius: 9999px;
  background: rgba(15, 23, 42, 0.72);
  color: #fff;
  font-weight: 700;
  border: 1px solid #0f172a;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.35);
  pointer-events: none;
  user-select: none;
  font-size: 14px;
  line-height: 1;
}

/* Center camera activation button */
#efw-start-center {
  position: absolute;
  z-index: 4;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  padding: 16px 32px;
  border-radius: 12px;
  border: none;
  background: #0f172a;
  color: #fff;
  font-size: 18px;
  font-weight: 700;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
  cursor: pointer;
  transition: all 0.3s ease;
  opacity: 1;
  pointer-events: auto;
}
#efw-start-center:hover {
  background: #1e293b;
  transform: translate(-50%, -50%) scale(1.05);
}
#efw-start-center:active {
  transform: translate(-50%, -50%) scale(0.98);
}
.camera-running #efw-start-center {
  opacity: 0;
  pointer-events: none;
}

/* Floating color panel */
.efw-palette {
  position: absolute;
  z-index: 4;
  bottom: 100px;
  left: 50%;
  transform: translate(-50%, -8px) scale(0.98);
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.18s ease, transform 0.18s ease;
  background: transparent;
  border: 1px solid #e5e7eb;
  border-radius: 12px;
  box-shadow: 0 12px 32px rgba(0, 0, 0, 0.15);
  width: min(92%, 520px);
  padding: 12px;
}
.efw-video-wrap.palette-open .efw-palette {
  opacity: 1;
  transform: translate(-50%, 0) scale(1);
  pointer-events: auto;
}

/* Floating color button */
#efw-fab {
  position: absolute;
  z-index: 4;
  bottom: 40px;
  left: 50%;
  transform: translateX(-50%);
  width: 56px;
  height: 56px;
  border-radius: 9999px;
  border: none;
  background: #0f172a;
  color: #fff;
  box-shadow: 0 8px 18px rgba(0, 0, 0, 0.22);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  font-size: 22px;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.3s ease;
}
#efw-fab:hover {
  transform: translateX(-50%) scale(1.05);
  filter: brightness(1.10);
}
#efw-fab:active {
  transform: translateX(-50%) scale(0.90);
}
.camera-running #efw-fab {
  opacity: 1;
  pointer-events: auto;
}

/* Brightness boost button */
#efw-bright-boost {
  position: absolute;
  z-index: 4;
  bottom: 40px;
  left: calc(50% - 72px);
  transform: translateX(-50%);
  width: 56px;
  height: 56px;
  border-radius: 9999px;
  border: none;
  background: #0f172a;
  color: #fff;
  box-shadow: 0 8px 18px rgba(0, 0, 0, 0.22);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  font-size: 22px;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.3s ease;
}
#efw-bright-boost:hover {
  transform: translateX(-50%) scale(1.05);
  filter: brightness(1.10);
}
#efw-bright-boost:active {
  transform: translateX(-50%) scale(0.90);
}
.camera-running #efw-bright-boost {
  opacity: 1;
  pointer-events: auto;
}
.efw-video-wrap.palette-open #efw-bright-boost {
  opacity: 0;
  pointer-events: none;
}
/* â€œused onceâ€ state */
/* #efw-bright-boost.is-used {
  opacity: 0.5;
  pointer-events: none;
} */


/* Floating print button */
#efw-capture {
  position: absolute;
  z-index: 4;
  bottom: 40px;
  left: calc(50% + 72px);
  transform: translateX(-50%);
  width: 56px;
  height: 56px;
  border-radius: 9999px;
  border: none;
  background: #0f172a;
  color: #fff;
  box-shadow: 0 8px 18px rgba(0, 0, 0, 0.22);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  font-size: 22px;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.3s ease;
}
#efw-capture:hover {
  transform: translateX(-50%) scale(1.05);
  filter: brightness(1.10);
}
#efw-capture:active {
  transform: translateX(-50%) scale(0.90);
}
.camera-running #efw-capture {
  opacity: 1;
  pointer-events: auto;
}
.efw-video-wrap.palette-open #efw-capture {
  opacity: 0;
  pointer-events: none;
}

/* Color name tag */
.efw-color-tag {
  position: absolute;
  z-index: 4;
  bottom: 6px;
  padding: 6px 12px;
  border-radius: 9999px;
  justify-self: center;
  background: rgba(15, 23, 42, 0.72);
  color: #fff;
  font-weight: 700;
  font-size: 12px;
  line-height: 1;
  border: 1px solid rgba(255, 255, 255, 0.18);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.25);
  backdrop-filter: saturate(120%) blur(4px);
  -webkit-backdrop-filter: saturate(120%) blur(4px);
  pointer-events: none;
  opacity: 1;
  transition: opacity 0.2s ease;
  white-space: nowrap;
}
.efw-video-wrap.palette-open .efw-color-tag {
  opacity: 0;
}

</style>
</head>
<body>
<div id="eye-filter-widget" >

  <div class="efw-card">
    <div class="efw-row">
      <div style="width: 100%;">
      <!-- <div > -->
        <div class="efw-video-wrap">
           <!-- Static logo fixed at the top of the camera window -->
           <div class="efw-logo">Kerato.Lifeï¸ğŸ‘</div>
          
           <!-- Camera launch button in the center -->
          <button id="efw-start-center" type="button">×”×¤×¢×œ ××¦×œ××”</button>

          <!-- Popup: 16 colors + intensity slider -->
          <div class="efw-palette" id="efw-palette" role="dialog" aria-hidden="true">
            <div class="efw-inline" style="margin-bottom:8px">
              <input id="efw-color" class="efw-color-input" type="hidden" value="#6AA6C9" aria-label="×‘×—×¨ ×¦×‘×¢" />
              <div class="efw-inline">
                <div class="efw-chip" data-color="none" title="No color"></div>
                <div class="efw-chip" data-color="#C8A89E" title="Dune" style="background:#C8A89E"></div>
                <div class="efw-chip" data-color="#8C5B3B" title="Sand ER19D" style="background:#8C5B3B"></div>
                <div class="efw-chip" data-color="#B8912E" title="Honey Gold" style="background:#B8912E"></div>
                <div class="efw-chip" data-color="#A27B34" title="Sahara" style="background:#A27B34"></div>
                <div class="efw-chip" data-color="#9B7B42" title="Tropical" style="background:#9B7B42"></div>
                <div class="efw-chip" data-color="#9CB08C" title="Savana" style="background:#9CB08C"></div>
                <div class="efw-chip" data-color="#6C8B5C" title="Pistache CT88" style="background:#6C8B5C"></div>
                <div class="efw-chip" data-color="#A6CBB7" title="Jade" style="background:#A6CBB7"></div>
                <div class="efw-chip" data-color="#C5DAD0" title="Arctique" style="background:#C5DAD0"></div>
                <div class="efw-chip" data-color="#95B7C7" title="Green Water" style="background:#95B7C7"></div>
                <div class="efw-chip active" data-color="#6AA6C9" title="Turquoise" style="background:#6AA6C9"></div>
                <div class="efw-chip" data-color="#5C82C4" title="New Blue" style="background:#5C82C4"></div>
                <div class="efw-chip" data-color="#4B5C91" title="Pacific" style="background:#4B5C91"></div>
                <div class="efw-chip" data-color="#8DB5E0" title="Azur" style="background:#8DB5E0"></div>
                <div class="efw-chip" data-color="#D4D9E8" title="Polar Grey" style="background:#D4D9E8"></div>
                <div class="efw-chip" data-color="#AFAFB9" title="Pearl" style="background:#AFAFB9"></div>
              </div>
                <!-- <div class="efw-inline">
                <div class="efw-chip efw-chip-none active" data-color="none" title="No color"></div>
                <div class="efw-chip" data-color="#b7a49d" title="Dune" style="background:#b7a49d"></div>
                <div class="efw-chip" data-color="#79655a" title="Sand ER19D" style="background:#79655a"></div>
                <div class="efw-chip" data-color="#947d51" title="Honey Gold" style="background:#947d51"></div>
                <div class="efw-chip" data-color="#947d51" title="Sahara" style="background:#947d51"></div>
                <div class="efw-chip" data-color="#998a69" title="Tropical" style="background:#998a69"></div>
                <div class="efw-chip" data-color="#8e9988" title="Savana" style="background:#8e9988"></div>
                <div class="efw-chip" data-color="#657960" title="Pistache CT88" style="background:#657960"></div>
                <div class="efw-chip" data-color="#abc0ad" title="Jade" style="background:#abc0ad"></div>
                <div class="efw-chip" data-color="#d5e4df" title="Arctique" style="background:#d5e4df"></div>
                <div class="efw-chip" data-color="#a1bccf" title="Green Water" style="background:#a1bccf"></div>
                <div class="efw-chip" data-color="#9bacbe" title="Turquoise" style="background:#9bacbe"></div>
                <div class="efw-chip" data-color="#8298c7" title="New Blue" style="background:#8298c7"></div>
                <div class="efw-chip" data-color="#7785a8" title="Pacific" style="background:#7785a8"></div>
                <div class="efw-chip" data-color="#c4d5ff" title="Azur" style="background:#c4d5ff"></div>
                <div class="efw-chip" data-color="#e6ebff" title="Polar Grey" style="background:#e6ebff"></div>
                <div class="efw-chip" data-color="#aeb2bd" title="Pearl" style="background:#aeb2bd"></div>
              </div> -->
            </div>

            <div class="efw-brightness-control" >
             
              <label class="efw-label">×¢×•×¦××ª ×”×¦×‘×¢:</label>
              <!-- @ to change the intensity of the color filter to 45% or 55% change the max -->
              <input id="efw-alpha" class="efw-slider" type="hidden" min="10" max="32" value="26"  />
                 <select class="efw-intensity-btn" >
                    <!-- <option class="efw-intensity-btn" value="">--×ª×‘×—×¨ ××ª ×‘×”×™×¨×•×ª ×”×¦×‘×¢--</option> -->
                    <option value="20">× ××•×š</option>
                    <option value="26" selected>×××•×¦×¢</option>
                    <option value="32">×’×‘×•×”</option>


                    <!-- <option value="33">× ××•×š</option>
                    <option value="45" selected>×××•×¦×¢</option>
                    <option value="55">×’×‘×•×”</option> -->

                    
                    <!-- <option value="20">× ××•×š</option>
                    <option value="32" selected>×××•×¦×¢</option>
                    <option value="45">×’×‘×•×”</option> -->

                 </select>
            </div>

          </div>

          <video id="efw-video" playsinline autoplay muted></video>
          <canvas id="efw-canvas"></canvas>

          <!-- Floating round button to open/close the panel -->
          <button id="efw-fab" type="button" title="×‘×—×™×¨×ª ×¦×‘×¢" aria-controls="efw-palette" aria-expanded="false">ğŸ¨</button>
        
          <!-- Brightness boost button -->
          <button id="efw-bright-boost" type="button" title="×™×© ×¡×™×›×•×™ ×©×œ××—×¨ ×”× ×™×ª×•×— ×ª×”×™×” ×‘×”×™×¨×•×ª ××•×’×‘×¨×ª" aria-label="×”×’×‘×¨×ª ×‘×”×™×¨×•×ª">ğŸ”…</button>

          <!--  Start updated UI  -->

          <!-- Button to capture pictures -->
          <button id="efw-capture" type="button" title="×¦×™×œ×•×" aria-label="×¦×™×œ×•×">ğŸ“¸</button>
          <div id="efw-color-tag" class="efw-color-tag" aria-live="polite"></div>
        
          <!--  End updated UI  -->
      
        </div>
        <div id="efw-status" class="efw-status efw-small">×œ×—×¥ ×¢×œ "×”×¤×¢×œ ××¦×œ××”" ×œ×”×ª×—×œ×”</div>
        <button id="efw-stop" class="efw-btn sec" disabled style="margin-top:16px;padding:14px 32px">×¢×¦×•×¨ ××¦×œ××”</button>
      </div>
    </div>
  </div>
<script>
  (function(){
    'use strict';


/* --- Debugging Functions --- */

// to use them I already implemented them, just search the
// function name and uncomment the function to call it

// debug: draws dots at every eyelid landmark point for both eyes
function debug_drawDotsEyelids(ctx, currEyelids) {
  ctx.fillStyle = '#FF0000';
  
  if(currEyelids.left){
    for (const pt of currEyelids.left) {
      ctx.beginPath();
      ctx.arc(pt.x, pt.y, 1, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  if(currEyelids.right){    
    for (const pt of currEyelids.right) {
      ctx.beginPath();
      ctx.arc(pt.x, pt.y, 1, 0, Math.PI * 2);
      ctx.fill();
    }
  }
}
    
// debug: draws outlined shapes connecting the eyelid points for each eye
function debug_drawEyelids(ctx, currEyes, currEyelids) {
  
  if (currEyes.left && currEyelids.left) {
    ctx.strokeStyle = '#00FF00';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(currEyelids.left[0].x, currEyelids.left[0].y);
  
    for (let i = 1; i < currEyelids.left.length; i++) {
      ctx.lineTo(currEyelids.left[i].x, currEyelids.left[i].y);
    }
    ctx.closePath();
    ctx.stroke();
  }
  
    if (currEyes.right && currEyelids.right) {
    ctx.strokeStyle = '#00fff2ff';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(currEyelids.right[0].x, currEyelids.right[0].y);
  
    for (let i = 1; i < currEyelids.right.length; i++) {
      ctx.lineTo(currEyelids.right[i].x, currEyelids.right[i].y);
    }
    ctx.closePath();
    ctx.stroke();
  }

debug_drawDotsEyelids(ctx, currEyelids);
}

// debug: draw all landmarks (dots + optional index labels)
function debug_drawAllLandmarks(ctx, landmarks, { showIndex = false, color = 'red', size = 2 } = {}) {
    if (!landmarks || !landmarks.length) return;
    ctx.save();
    ctx.fillStyle = color;
    ctx.strokeStyle = color;
    ctx.lineWidth = 1;
    ctx.font = '10px sans-serif';
    for (let i = 0; i < landmarks.length; i++) {
        const p = landmarks[i];
        // convert normalized coords -> canvas coords
        const x = Math.round(p.x * canvas.width);
        const y = Math.round(p.y * canvas.height);
        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI * 2);
        ctx.fill();
        if (showIndex) {
            // small offset so number doesn't overlap the dot
            ctx.fillText(String(i), x + size + 1, y - size - 1);
        }
    }
    ctx.restore();
}

// debug: print landmark list to console (useful to export)
function debug_logLandmarks(landmarks) {
    if (!landmarks) return;
    const pts = landmarks.map((p, i) => ({ i, x: p.x * canvas.width, y: p.y * canvas.height, z: p.z }));
    console.table(pts);
}

// debug: return array of indices whose projected position is within px radius of a center landmark
function debug_getLandmarksNear(landmarks, centerIdx, pxRadius = 40){
    if (!landmarks || !landmarks[centerIdx]) return [];
    const cx = landmarks[centerIdx].x * canvas.width;
    const cy = landmarks[centerIdx].y * canvas.height;
    const out = [];
    for (let i = 0; i < landmarks.length; i++){
        const p = landmarks[i];
        const x = p.x * canvas.width, y = p.y * canvas.height;
        const d = Math.hypot(x - cx, y - cy);
        if (d <= pxRadius) out.push(i);
    }
    return out;
}

// debug: draw small numbered dots for a list of indices
function debug_drawIndices(ctx, landmarks, indices, { color = 'cyan', size = 2 } = {}){
    if (!landmarks || !indices || !indices.length) return;
    ctx.save();
    ctx.fillStyle = color;
    ctx.strokeStyle = color;
    ctx.font = '10px sans-serif';
    for (const i of indices){
        const p = landmarks[i];
        const x = Math.round(p.x * canvas.width);
        const y = Math.round(p.y * canvas.height);
        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI*2);
        ctx.fill();
        ctx.fillText(String(i), x + size + 1, y - size - 1);
    }
    ctx.restore();
}

// helper that returns a union of predefined eye indices (upper+lower+iris ring)
function debug_getKnownEyeIndices(side = 'left'){
    if (side === 'left') return Array.from(new Set([].concat(LEFT_EYE_UPPER, LEFT_EYE_LOWER, LEFT_IRIS_RING, [LEFT_IRIS_CENTER])));
    return Array.from(new Set([].concat(RIGHT_EYE_UPPER, RIGHT_EYE_LOWER, RIGHT_IRIS_RING, [RIGHT_IRIS_CENTER])));
}

// debug helpers: list & draw every landmark that belongs to the right eye
const DEBUG_SHOW_RIGHT_EYE = true;

// debug: checks whether a given point lies inside a polygon
function debug_pointInPoly(point, poly){
    // ray-casting / winding test
    if (!poly || !poly.length) return false;
    let x = point.x, y = point.y, inside = false;
    for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
        const xi = poly[i].x, yi = poly[i].y;
        const xj = poly[j].x, yj = poly[j].y;
        const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi + 0.0000001) + xi);
        if (intersect) inside = !inside;
    }
    return inside;
}

// debug: analyzes all facial landmarks and returns groups of right-eye-related indices
function debug_getRightEyeLandmarkLists(landmarks, radiusPx = 48){
    if (!landmarks || !landmarks.length) return null;
    // Known sets from constants in file
    const known = Array.from(new Set([].concat(RIGHT_EYE_UPPER, RIGHT_EYE_LOWER, RIGHT_IRIS_RING, [RIGHT_IRIS_CENTER])));
    // compute center in canvas coords
    const centerPt = landmarks[RIGHT_IRIS_CENTER] ? { x: landmarks[RIGHT_IRIS_CENTER].x * canvas.width, y: landmarks[RIGHT_IRIS_CENTER].y * canvas.height } : null;
    // build eyelid polygon in canvas coords
    const eyelidPoly = buildEyeClip(landmarks, RIGHT_EYE_UPPER, RIGHT_EYE_LOWER);
    const nearCenter = [];
    const insideEyelid = [];
    const coords = {};
    for (let i = 0; i < landmarks.length; i++){
        const p = landmarks[i];
        if (!p) continue;
        const cx = p.x * canvas.width, cy = p.y * canvas.height;
        coords[i] = { x: cx, y: cy, z: p.z };
        if (centerPt){
            const d = Math.hypot(cx - centerPt.x, cy - centerPt.y);
            if (d <= radiusPx) nearCenter.push(i);
        }
        if (eyelidPoly && eyelidPoly.length){
            if (debug_pointInPoly({x:cx,y:cy}, eyelidPoly)) insideEyelid.push(i);
        }
    }
    return { known, nearCenter, insideEyelid, coords, centerPt, eyelidPoly };
}

// debug: draws the selected right-eye landmark points
function debug_drawRightEyeLandmarks(ctx, lists, { showIndex=true } = {}){
    if (!lists) return;
    // draw known set (orange)
    debug_drawIndices(ctx, Object.keys(lists.coords).map(k => ({x: lists.coords[k].x/canvas.width, y: lists.coords[k].y/canvas.height})), []); // noop to keep helper available
    // draw categories
    const draw = (indices, color, size=3) => {
        ctx.save();
        ctx.fillStyle = color; ctx.strokeStyle = color; ctx.font = '12px monospace';
        for (const i of indices){
            const p = lists.coords[i];
            if (!p) continue;
            ctx.beginPath(); ctx.arc(p.x, p.y, size, 0, Math.PI*2); ctx.fill();
            if (showIndex) ctx.fillText(String(i), p.x + size + 1, p.y - size - 2);
        }
        ctx.restore();
    };

    // more left eye landmark - [33, 246, 161, 160, 159, 158, 157, 173, 133, 155, 154, 153, 145, 144, 163, 7]
    // more right eye landmark - [463, 398, 384, 385, 386, 387, 388, 466, 263, 249, 390, 373, 374, 380, 381, 382, 362]
    
    /*

      // Left eye
      const LEFT_EYE_LOWER = [33, 7, 163, 144, 145, 153, 154, 155]
      const LEFT_EYE_UPPER = [133, 173, 157, 158, 159, 160, 161, 246]

      // Right eye
      const RIGHT_EYE_LOWER = [263, 249, 390, 373, 374, 380, 381, 382]
      const RIGHT_EYE_UPPER = [362, 398, 384, 385, 386, 387, 388, 466]

    */


    // tests:
    // draw(lists.known, '#ff9900', 3);
    // draw([386, 374, 263, 362], '#c800ffff', 4); // right eye
    // draw([159, 145, 33, 133], '#c800ffff', 4); // left eye

    // optional: outline eyelid polygon
    if (lists.eyelidPoly && lists.eyelidPoly.length){
        ctx.save();
        ctx.strokeStyle = '#66ff66'; ctx.lineWidth = 1; ctx.beginPath();
        ctx.moveTo(lists.eyelidPoly[0].x, lists.eyelidPoly[0].y);
        for (let i=1;i<lists.eyelidPoly.length;i++) ctx.lineTo(lists.eyelidPoly[i].x, lists.eyelidPoly[i].y);
        ctx.closePath(); ctx.stroke(); ctx.restore();
    }
}

    /* --- Get Elements from HTML --- */

    // receives the webcam stream
    const video = document.getElementById('efw-video'); 

    // draw the video frame and overlays
    const canvas = document.getElementById('efw-canvas'); 

    // 2D drawing context for the canvas
    const ctx = canvas.getContext('2d', { alpha: false }); 

    // shows status / messages to the user
    const statusEl = document.getElementById('efw-status'); 

    // "start camera" button
    const btnStartCenter = document.getElementById('efw-start-center'); 

    // "stop camera" button
    const btnStop  = document.getElementById('efw-stop'); 

    // color input for selecting the eye filter color
    const colorInp = document.getElementById('efw-color'); 

    // input controlling the filter's transparency
    const alphaInp = document.getElementById('efw-alpha'); 

    // button for opening the color palette
    const fabBtn = document.getElementById('efw-fab'); 

    // main video that wraps the camera and overlays
    const wrapEl = document.querySelector('.efw-video-wrap'); 

    // color palette panel for selecting filter colors
    const pal = document.getElementById('efw-palette'); 

    // button used to capture and download a snapshot
    const btnCapture = document.getElementById('efw-capture'); 
   
    // displays the name of the currently selected eye filter color
    const colorTag = document.getElementById('efw-color-tag'); 

    // Brightness control container
    const brightnessControlEl = document.querySelector('.efw-brightness-control'); 

    // Brightness boost button (+10%)
    const brightBoostBtn = document.getElementById('efw-bright-boost');
    const BRIGHT_BOOST_STEP = 10
    let isBrightBoostOn = false

    // Intensity btn
    const intensitySelect = document.querySelector('select.efw-intensity-btn');

    let prevAlphaBeforeNone = null


    /* --- Utility functions for color manipulation --- */

    // clamp value to range
    function clamp(v, min, max){ return v < min ? min : (v > max ? max : v); }
    
    // convert hex to RGB
    function hexToRgb(hex){
      if (!hex) return {r: 183, g: 164, b: 157};
      let h = hex.trim().replace('#','');
      if (h.length === 3) h = h.split('').map(c => c + c).join('');
      const num = parseInt(h, 16);
      if (Number.isNaN(num)) return {r: 183, g: 164, b: 157};
      return { r: (num >> 16) & 255, g: (num >> 8) & 255, b: num & 255 };
    }
    
    // convert RGB to hex
    function rgbToHex(r,g,b){
      const toHex = (n)=> clamp(Math.round(n),0,255).toString(16).padStart(2,'0');
      return '#' + toHex(r) + toHex(g) + toHex(b);
    }

    // returns darker hex color
    function darkenHex(hex, amount){
      const {r,g,b} = hexToRgb(hex);
      return rgbToHex(r*(1-amount), g*(1-amount), b*(1-amount));
    }

    // returns brighter hex color
    function brightenHex(hex, amount){
      const {r,g,b} = hexToRgb(hex);
      return rgbToHex(r + (255-r)*amount, g + (255-g)*amount, b + (255-b)*amount);
    }

    // update background gradient
    function setWrapBgFromColor(hex){
      if (!wrapEl) return;
      const c1 = darkenHex(hex, 0.40);
      const c2 = darkenHex(hex, 0.70);
      wrapEl.style.background = `linear-gradient(135deg, ${c2}, ${c1})`;

      const brightnessPercent = alphaInp.value / 100
      const brightColor = brightenHex(hex, brightnessPercent); // Adjust 0.15 for more/less brightness
      brightnessControlEl.style.backgroundColor = brightColor;
    }

    // find active color chip
    function getSelectedChip(){
      const active = document.querySelector('.efw-chip.active');
      if (active) return active;
      const chips = document.querySelectorAll('.efw-chip');
      const val = (colorInp.value||'').toLowerCase();
      for (const ch of chips){ if ((ch.dataset.color||'').toLowerCase() === val) return ch; }
      return null;
    }

    // update color name display
    function updateColorTag(){
      if (!colorTag) return;
      const chip = getSelectedChip();
      const name = (chip && (chip.getAttribute('title') || (chip.textContent||'').trim())) || (colorInp.value||'');
      colorTag.textContent = name;
    }

    // Initial activation according to the default alliance
    setWrapBgFromColor(colorInp.value);
    updateColorTag();
    
// console.log('Checking elements:', { fabBtn, wrapEl, pal, intensitySelectOption });

   // End Color Tag
    if (fabBtn && wrapEl && pal){
     
      fabBtn.addEventListener('click', ()=>{
        const isOpen = wrapEl.classList.toggle('palette-open');
        fabBtn.setAttribute('aria-expanded', String(isOpen));
        pal.setAttribute('aria-hidden', String(!isOpen));
      });

        intensitySelect.addEventListener('change', ()=>{
        console.log('click')
        const isOpen = wrapEl.classList.toggle('palette-open');
        fabBtn.setAttribute('aria-expanded', String(isOpen));
        pal.setAttribute('aria-hidden', String(!isOpen));
      });


    }


    /* --- Configuration & State --- */

    // canvas blend mode
    const blendMode = 'source-over'; 

    // camera running state
    let running = false; 

    // media stream
    let stream = null; 

    // face detection model
    let faceMesh = null; 

    // animation frame ID
    let animationId = null; 

    // detected eye positions
    let currentEyes = { right: null, left: null }; 

    // eyelid polygon data
    let currentEyelids = { right: null, left: null }; 
    
    // BUG - this is a test solution for the bug when the hand in front of eye doesn't remove color filter 
    // let rightIrisDetected = false;
    // let leftIrisDetected = false;

    // iris rendering parameters
    const REALISM = {
      SIZE_MULTIPLIER: 0.92,
      MIN_RADIUS: 6,
      MAX_RADIUS: 38,
      IRIS_SHRINK: 0.92,
      RING_MARGIN: 1.08, // 1.05 0.98 0.92
      PUPIL_RATIO: 0.32,
      LIMBAL_WIDTH: 0.18, // Control the limbal ring (dark ring around the iris)
      LIMBAL_ALPHA: 0.55, // Control the limbal ring (dark ring around the iris)
      HIGHLIGHT_ALPHA: 0.35, // Light reflection on the cornea
      HIGHLIGHT_OFFSET: 0.28, // Light reflection on the cornea
      FIBER_COUNT: 36, 
      FIBER_ALPHA: 0.14, // Affect iris texture contrast
      FIBER_INNER: 0.28,
      FIBER_OUTER: 0.95,
      EDGE_DARKEN: 0.25, // Darkens the outer edge of the iris
      INNER_GLOW: 0.20, // Adds a subtle bright ring inside the iris
      SMOOTHING: 0.35,
      CENTER_BLEND: 0.75, // Controls how the pupil blends with the iris
      CENTER_Y_OFFSET: -0.06, // Slightly shifts the iris center
      FIBER_JITTER: 0.06,
      FIBER_LIGHT_ALPHA: 0.06, // Affect iris texture contrast
      FIBER_CLEAR_COUNT: 0,
      FIBER_CLEAR_ALPHA: 0,
      FIBER_CLEAR_THICKNESS: 0.5,
      FIBER_CLEAR_INNER: 0.20,
      FIBER_CLEAR_OUTER: 0.97,
      BAND_COUNT: 4,
      BAND_ALPHA: 0.06, // Adds concentric darker bands
      FILL_BOOST_ALPHA: 0.12
    };

    // eyelid clipping settings
    const EYELID_MASK = {
      ENABLED: true,
      CLIP_STRENGTH: 0.55,
      BLUR_PX: 0.4
    };



    // blink sensitivity thresholds:
    const BLINK = { T0: 0.10, T1: 0.18 }; // Ramp: below T0 turns off, between T0 and T1 fades, above T1 full

    // drawing noise onto the element
    const noiseCanvas = document.createElement('canvas');

    // 2D drawing context so you can draw on the canvas
    const noiseCtx = noiseCanvas.getContext('2d');

    // Sets the canvas width
    noiseCanvas.width = 64;

    // Sets the canvas height
    noiseCanvas.height = 64;


    /* --- Configuration & State --- */

    // shadows & lighting
    const eyeColorLayer = document.createElement('canvas');

    // iris color
    const eyeColorCtx = eyeColorLayer.getContext('2d');

    // visible area mask
    const eyeShadeLayer = document.createElement('canvas');

    // combines all of them
    const eyeShadeCtx = eyeShadeLayer.getContext('2d');
    
    // ensure eyeColorLayer and eyeShadeLayer have size S and clear them
    function ensureEyeLayersSize(size){
      const s = Math.max(16, Math.ceil(size));
      if (eyeColorLayer.width !== s || eyeColorLayer.height !== s){ eyeColorLayer.width = s; eyeColorLayer.height = s; }
      if (eyeShadeLayer.width !== s || eyeShadeLayer.height !== s){ eyeShadeLayer.width = s; eyeShadeLayer.height = s; }
      eyeColorCtx.clearRect(0,0,s,s);
      eyeShadeCtx.clearRect(0,0,s,s);
    }

    // Base circular mask for eye color
    const eyeMaskLayer = document.createElement('canvas'); // Creates a canvas element to store the base iris mask (white circle representing the eye boundary)
    
    // Draws + clips the main mask
    const eyeMaskCtx = eyeMaskLayer.getContext('2d'); // Gets the 2D drawing context for the eyeMaskLayer to draw on it

    // Blurred copy of main mask
    const eyeMaskFeather = document.createElement('canvas'); // Creates a canvas for a blurred/feathered version of the iris mask for smooth edges
    
    // Blurs the main mask
    const eyeMaskFeatherCtx = eyeMaskFeather.getContext('2d'); // Gets the 2D drawing context for the eyeMaskFeather to apply blur effects

    // Eyelid cutout (white with transparent hole)
    const eyeCutLayer = document.createElement('canvas'); // Creates a canvas to store the eyelid shape that will be subtracted/cut from the iris
    
    // Draws and erases eyelid shape
    const eyeCutCtx = eyeCutLayer.getContext('2d'); // Gets the 2D drawing context for the eyeCutLayer to draw the eyelid polygon

    // Blurred eyelid mask
    const eyeCutFeather = document.createElement('canvas'); // Creates a canvas for a blurred version of the eyelid cutout for smooth transitions
    
    // Blurs eyelid mask edges
    const eyeCutFeatherCtx = eyeCutFeather.getContext('2d'); // Gets the 2D drawing context for the eyeCutFeather to apply blur effects to the eyelid mask

    // ensure mask/cut/feather canvases are sized and cleared
    function ensureMaskSize(size){
      const s = Math.max(16, Math.ceil(size));
      if (eyeMaskLayer.width !== s || eyeMaskLayer.height !== s){ eyeMaskLayer.width = s; eyeMaskLayer.height = s; }
      if (eyeMaskFeather.width !== s || eyeMaskFeather.height !== s){ eyeMaskFeather.width = s; eyeMaskFeather.height = s; }
      if (eyeCutLayer.width !== s || eyeCutLayer.height !== s){ eyeCutLayer.width = s; eyeCutLayer.height = s; }
      if (eyeCutFeather.width !== s || eyeCutFeather.height !== s){ eyeCutFeather.width = s; eyeCutFeather.height = s; }
      eyeMaskCtx.clearRect(0,0,s,s);
      eyeMaskFeatherCtx.clearRect(0,0,s,s);
      eyeCutCtx.clearRect(0,0,s,s);
      eyeCutFeatherCtx.clearRect(0,0,s,s);
    }


    /* --- Blend Modes And Picks a Safe Fallback --- */

    const testCtx = document.createElement('canvas').getContext('2d');
   
    // detection for common compositing operations
    const BLEND_SUPPORT = {};

    ['multiply','screen','overlay','color','source-over','lighter'].forEach(m=>{
      try{ testCtx.globalCompositeOperation = m; BLEND_SUPPORT[m] = (testCtx.globalCompositeOperation === m); }
      catch(_){ BLEND_SUPPORT[m] = false; }
    });
    
    // pick a supported fallback for a requested blend mode
    function resolveBlendMode(requested){
      if (BLEND_SUPPORT[requested]) return requested;
      if (requested === 'color') return BLEND_SUPPORT['multiply'] ? 'multiply' : 'source-over';
      if (requested === 'overlay') return BLEND_SUPPORT['multiply'] ? 'multiply' : 'source-over';
      if (requested === 'screen') return BLEND_SUPPORT['lighter'] ? 'lighter' : 'source-over';
      return 'source-over';
    }

    // landmark index lists to locate the iris and eyelid shapes for each eye
    const RIGHT_IRIS_RING = [468,471,470,469]; 
    const RIGHT_IRIS_CENTER = 472;
    
    const LEFT_IRIS_RING = [473,474,475,476];
    const LEFT_IRIS_CENTER = 477;

    // Right eye
    const RIGHT_EYE_LOWER = [33, 7, 163, 144, 145, 153, 154, 155]
    const RIGHT_EYE_UPPER = [133, 173, 157, 158, 159, 160, 161, 246]

    // Left eye
    const LEFT_EYE_LOWER = [263, 249, 390, 373, 374, 380, 381, 382]
    const LEFT_EYE_UPPER = [362, 398, 384, 385, 386, 387, 388, 466]

     /* --- Utility Functions For Status, Security, Sizing and Math --- */

    // Show message to the user
    function setStatus(msg, isOk = null) {
      statusEl.textContent = msg || '';
      statusEl.className = 'efw-status efw-small';
      if (isOk === true)  statusEl.className += ' efw-status-ok';
      if (isOk === false) statusEl.className += ' efw-status-bad';
    }
    
    // show animated loading text
    function setLoadingStatus(msg) {
      statusEl.innerHTML = msg + ' <span class="loading-dot"></span><span class="loading-dot"></span><span class="loading-dot"></span>';
      statusEl.className = 'efw-status efw-small';
    }
    // returns true if page is HTTPS or localhost
    function isSecureContext() {
      return location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1';
    }

    // set main canvas to video size
    function updateCanvasSize() {
      const w = video.videoWidth || 640;
      const h = video.videoHeight || 480;
      if (canvas.width !== w || canvas.height !== h) {
        canvas.width = w; canvas.height = h;
      }
    }

    // simple pseudo-random helpers
    function fract(x){ return x - Math.floor(x); }
    function prand(seed){ return fract(Math.sin(seed*12.9898)*43758.5453); }

    // Blink/openness helpers:

    // Euclidean distance between points
    function dist(a,b){ return Math.hypot(a.x - b.x, a.y - b.y); }
   
    // canvas coords helper
    function pt(L,i){ return { x: L[i].x * canvas.width, y: L[i].y * canvas.height }; }
   
    // clamp between 0 and 1
    function clamp01(x){ return x < 0 ? 0 : (x > 1 ? 1 : x); }


    /* --- Eye Geometry & Smoothing --- */

    // returns normalized openness = vertical distance / horizontal distance
    function eyeOpenness(L, upIdx, lowIdx, leftIdx, rightIdx) {
      const up = L[upIdx], low = L[lowIdx], l = L[leftIdx], r = L[rightIdx];
      if (!up || !low || !l || !r) return 1;
      return clamp01(dist(pt(L, upIdx), pt(L, lowIdx)) / Math.max(1, dist(pt(L, leftIdx), pt(L, rightIdx))));
    }

    // ease between a and b
    function smoothstep(a,b,x){ const t = Math.max(0, Math.min(1, (x - a)/(b - a))); return t*t*(3-2*t); }

    // calculate the center of the eye 
    function calculateEyeCenter(landmarks, ringIndices, centerIdx) {
      const W = canvas.width, H = canvas.height;
      if (Number.isInteger(centerIdx) && landmarks[centerIdx]) {
        return { x: landmarks[centerIdx].x * W, y: landmarks[centerIdx].y * H };
      }
      let sumX = 0, sumY = 0, n = 0;
      for (const idx of ringIndices) {
        const p = landmarks[idx]; if (!p) continue;
        sumX += p.x * W; sumY += p.y * H; n++;
      }
      return { x: sumX / Math.max(1,n), y: sumY / Math.max(1,n) };
    }

    // average distance from ring points to center 
    function calculateEyeRadius(center, landmarks, ringIndices) {
      let total = 0, n = 0, minD = Infinity;
      for (const idx of ringIndices) {
        const p = landmarks[idx]; if (!p) continue;
        const px = p.x * canvas.width, py = p.y * canvas.height;
        const d = Math.hypot(px - center.x, py - center.y);
        total += d; n++; if (d < minD) minD = d;
      }
      const avgRadius = total / Math.max(1,n);
      const safeByRing = isFinite(minD) ? (minD * REALISM.RING_MARGIN) : avgRadius;
      const base = Math.min(avgRadius * REALISM.SIZE_MULTIPLIER, safeByRing);
      return Math.max(REALISM.MIN_RADIUS, Math.min(REALISM.MAX_RADIUS, base));
    }

    // nudge center towards iris ring centroid and apply vertical offset (REALISM.CENTER_Y_OFFSET) 
    function biasEyeCenter(centerRaw, radius, ringIndices, landmarks){
      let ax=0, ay=0, n=0;
      for (const idx of ringIndices){
        const p = landmarks[idx]; if (!p) continue;
        ax += p.x * canvas.width; ay += p.y * canvas.height; n++;
      }
      if (n>0){
        const avg = { x: ax/n, y: ay/n };
        const t = Math.max(0, Math.min(1, REALISM.CENTER_BLEND));
        centerRaw = { x: centerRaw.x + (avg.x - centerRaw.x)*t, y: centerRaw.y + (avg.y - centerRaw.y)*t };
      }
      const dy = (REALISM.CENTER_Y_OFFSET||0) * (radius||0);
      return { x: centerRaw.x, y: centerRaw.y + dy };
    }

    // convert landmark indices array to canvas-coordinate points
    function ptsFromIndices(landmarks, indices){
      const W = canvas.width, H = canvas.height;
      const pts = [];
      for (const i of indices){
        const p = landmarks[i];
        if (p) pts.push({x: p.x*W, y: p.y*H});
      }
      return pts;
    }
    
    // builds combined polygon
    function buildEyeClip(landmarks, upperIdx, lowerIdx){
      const up = ptsFromIndices(landmarks, upperIdx);
      const low = ptsFromIndices(landmarks, lowerIdx);

      if (up.length < 2 || low.length < 2) return null;
      
       return up.concat(low); 
    }

    // decide whether a detected center is left or right eye by comparing to currentEyes centers 
    function getEyeSide(center){
      if (!currentEyes.left && !currentEyes.right) return null;
      const dl = currentEyes.left ? Math.hypot(center.x-currentEyes.left.center.x, center.y-currentEyes.left.center.y) : Infinity;
      const dr = currentEyes.right? Math.hypot(center.x-currentEyes.right.center.x, center.y-currentEyes.right.center.y) : Infinity;
      return (dl <= dr) ? 'left' : 'right';
    }

    // blend eyelid polygon points across frames
    function smoothPoly(prev, next){
      if (!next) return null;
      if (!prev) return next;
      const t = 1 - REALISM.SMOOTHING;
      const m = Math.min(prev.length, next.length);
      const out = [];
      for (let i=0; i<m; i++){
        const a = prev[i], b = next[i];
        out.push({ x: a.x + (b.x - a.x)*t, y: a.y + (b.y - a.y)*t });
      }
      for (let i=m; i<next.length; i++) out.push(next[i]);
      return out;
    }


    /* --- Renders Iris Color and Shading --- */
    /*(using masks, eyelids, and face-tracking)*/

    // paint the eye with color and shading
    function paintEye(center, radius, color, alpha, blendMode) {
      if (!center || !radius || radius < 3) return;
      const r = Math.max(REALISM.MIN_RADIUS, Math.min(REALISM.MAX_RADIUS, radius * REALISM.IRIS_SHRINK));
      const S = Math.ceil(r*2 + 4);
      ensureEyeLayersSize(S);

      const sideForMask = getEyeSide(center);
      const lidPoly = sideForMask && currentEyelids[sideForMask] ? currentEyelids[sideForMask] : null;
     
      ensureMaskSize(S);


      function buildEyelidMask(ec, lidPoly, center, S){

        // 1ï¸âƒ£  Create eyelid cut mask (no shadows)    
          ec.save();
          ec.translate(S/2, S/2);

          // White background â€” this defines the area that will be clipped out (square)
          ec.fillStyle = 'rgba(255,255,255,1)';
          ec.fillRect(-S/2, -S/2, S, S);

          // Subtract the eyelid polygon area (cutout)
          ec.globalCompositeOperation = 'destination-out';

          ec.beginPath();
          ec.moveTo(lidPoly[0].x - center.x, lidPoly[0].y - center.y);

          for (let i=1;i<lidPoly.length;i++){
            const p = lidPoly[i];
            ec.lineTo(p.x - center.x, p.y - center.y);
          }
          ec.closePath();
          ec.fill();

          ec.restore();

          // 2ï¸âƒ£ Light feather (very subtle blur just for soft edges)
          eyeCutFeatherCtx.save();
          eyeCutFeatherCtx.clearRect(0,0,S,S);
        
          try { eyeCutFeatherCtx.filter = `blur(${EYELID_MASK.BLUR_PX}px)`; } catch(_) {}

          eyeCutFeatherCtx.drawImage(eyeCutLayer, 0, 0);
          try { eyeCutFeatherCtx.filter = 'none'; } catch(_) {}
          eyeCutFeatherCtx.restore();


          // 3ï¸âƒ£ Apply to the mask â€” this part clips the color filter
          eyeMaskCtx.save();
          eyeMaskCtx.globalCompositeOperation = 'destination-out';

          eyeMaskCtx.drawImage(eyeCutFeather, 0, 0);
          eyeMaskCtx.restore();
      }

      
      // Draw source into ctx with blur filter for feathered mask
      function applyFeather(ctx, sourceCanvas) {        
        ctx.save();
        try { ctx.filter = `blur(${EYELID_MASK.BLUR_PX}px)` } catch(_) {}
        ctx.drawImage(sourceCanvas, 0, 0);
        try { ctx.filter = 'none'; } catch (_) {}
        ctx.restore();
      }


/*
Explanation, Step	Purpose:
1	    Create base circular mask
2	    If eyelid active, build a cut shape
3	    Erase that shape from mask
4	    Blur the edges for realism
5	    Apply to main eye mask with adjustable strength
6	    Feather the final result
*/

      (function buildMask(){

        // Create a circular white mask base
          eyeMaskCtx.save();
          eyeMaskCtx.clearRect(0,0,S,S);
          eyeMaskCtx.translate(S/2, S/2);
          eyeMaskCtx.beginPath();

          // create a circular base mask
          eyeMaskCtx.arc(0, 0, r, 0, 2 * Math.PI); // make it circle
          eyeMaskCtx.fill();
          
          eyeMaskCtx.restore();


        // Check if eyelid masking should happen
          if (EYELID_MASK.ENABLED && lidPoly && lidPoly.length >= 3){

            // the shadows are creating here
            buildEyelidMask(eyeCutCtx, lidPoly, center, S)
            }

          // Apply final feathering to the mask itself
          applyFeather(eyeMaskFeatherCtx, eyeMaskLayer);

      })();



      
  
      // draw the color into eyeColorCtx
      (function drawColor(){
      
      /*
        Explanation, eyeColorCtx:
        clip to circle, set globalAlpha = alpha, fill with selected color
        punch pupil hole via destination-out with radius r * PUPIL_RATIO
      */
        const cx = eyeColorCtx;
        cx.save();
        cx.clearRect(0,0,S,S);
        cx.translate(S/2, S/2);
       
        // Clip circle
        cx.beginPath(); cx.arc(0,0,r,0,Math.PI*2); cx.closePath(); cx.clip();
        cx.globalCompositeOperation = 'source-over';
        cx.globalAlpha = Math.min(1, alpha);
        cx.fillStyle = color;
        cx.fillRect(-r, -r, r*2, r*2);

        // Punch hole for pupil
        cx.globalCompositeOperation = 'destination-out';
        cx.globalAlpha = 1;
        cx.beginPath(); cx.arc(0,0, Math.max(2, r*REALISM.PUPIL_RATIO), 0, Math.PI*2);
        cx.fill();
        
        cx.restore();
      })();

      /*
        Explanation:
        After drawColor, apply eyeMaskFeather to both eyeColorCtx and eyeShadeCtx by setting
        globalCompositeOperation = 'destination-in' and drawImage(eyeMaskFeather).
        This ensures color & shade appear only inside the feathered mask
      */

      // Apply the masks the colors and the shading only within the eye shape
      eyeColorCtx.globalCompositeOperation = 'destination-in'; 
      eyeColorCtx.drawImage(eyeMaskFeather, 0, 0);
      eyeShadeCtx.globalCompositeOperation = 'destination-in';
      eyeShadeCtx.drawImage(eyeMaskFeather, 0, 0);

      ctx.save();


      // Draw the iris filter layers
      ctx.globalAlpha = 1;
      ctx.globalCompositeOperation = resolveBlendMode(blendMode);
      ctx.drawImage(eyeColorLayer, center.x - S/2, center.y - S/2);

      ctx.globalCompositeOperation = resolveBlendMode('screen');
      ctx.globalAlpha = REALISM.FILL_BOOST_ALPHA * alpha;
      ctx.drawImage(eyeColorLayer, center.x - S/2, center.y - S/2);

      ctx.globalAlpha = 1;
      ctx.globalCompositeOperation = resolveBlendMode('overlay');
      ctx.drawImage(eyeShadeLayer, center.x - S/2, center.y - S/2);
      ctx.restore();
    }

    // Get the face landmark points from the video and calculate the eye position in each frame
    function onFaceMeshResults(results) {

      /*
        Explanation:
        if no face landmarks: reset currentEyes and return.
        compute openL/openR via eyeOpenness,
        build eyelid polygons for left/right via buildEyeClip and smooth them,
        compute left/right iris centers and radii,
        bias centers, build next states for left/right (center, radius, open),
        smooth into currentEyes.left/right (so the overlay is not jumpy).
      */

      // If no faces are found, reset the eye state and exit the function
      if (!results.multiFaceLandmarks || !results.multiFaceLandmarks.length) {
        currentEyes = { left: null, right: null };
        return;
      }

      const landmarks = results.multiFaceLandmarks[0];
      
    // debug tests:

    // draws dots + indices on the main canvas
    // debug_drawAllLandmarks(ctx, landmarks, { showIndex: true, color: '#ff0000', size: 2 });

    // debug_logLandmarks(landmarks); // uncomment to print coordinates to console
    // debug_drawIndices(ctx, landmarks, RIGHT_EYE_LOWER);
    // debug_getKnownEyeIndices();

    // @ BUG - this is for the bug when the hand in front of eye doesn't remove color filter 
    // Check if iris landmarks are detected (not occluded)
    // rightIrisDetected = landmarks[RIGHT_IRIS_CENTER] && landmarks[RIGHT_IRIS_CENTER].z > -0.2;
    // leftIrisDetected = landmarks[LEFT_IRIS_CENTER] && landmarks[LEFT_IRIS_CENTER].z > -0.2;

      // debug test
      if (DEBUG_SHOW_RIGHT_EYE) {
        // const lists = debug_getRightEyeLandmarkLists(landmarks, 48); // adjust radiusPx if needed
        // if (lists) {
          // // print a compact table of indices + coords
          // const out = [];
          // for (const i of (new Set([].concat(lists.known, lists.nearCenter, lists.insideEyelid)))) {
          //   if (!lists.coords[i]) continue;
          //   out.push({ index: i, x: Math.round(lists.coords[i].x), y: Math.round(lists.coords[i].y), z: lists.coords[i].z,
          //              nearCenter: lists.nearCenter.includes(i), insideEyelid: lists.insideEyelid.includes(i), known: lists.known.includes(i) });
          // }
          // console.table(out);
          // // draw on canvas (visual)
          // debug_drawRightEyeLandmarks(ctx, lists, { showIndex: true });
        // }
        // console.table(lists.nearCenter)
      }
           
      
      const rightUpIdx = RIGHT_EYE_UPPER[0];
      const rightLowIdx = RIGHT_EYE_LOWER[0];
      const rightLeftIdx = RIGHT_EYE_LOWER[RIGHT_EYE_LOWER.length -1];
      const rightRightIdx = RIGHT_EYE_UPPER[RIGHT_EYE_UPPER.length -1];

      const leftUpIdx = LEFT_EYE_UPPER[0];
      const leftLowIdx = LEFT_EYE_LOWER[0];
      const leftLeftIdx = LEFT_EYE_LOWER[LEFT_EYE_LOWER.length -1];
      const leftRightIdx = LEFT_EYE_UPPER[LEFT_EYE_UPPER.length -1];

      // Calculate how open the eyes are
      const openR = eyeOpenness(landmarks, rightUpIdx, rightLowIdx, rightLeftIdx, rightRightIdx);
      const openL = eyeOpenness(landmarks, leftUpIdx, leftLowIdx, leftLeftIdx, leftRightIdx);
      
      const rightRawPoly = buildEyeClip(landmarks, RIGHT_EYE_UPPER, RIGHT_EYE_LOWER);
      const leftRawPoly  = buildEyeClip(landmarks, LEFT_EYE_UPPER, LEFT_EYE_LOWER);
    
      currentEyelids.right = smoothPoly(currentEyelids.right, rightRawPoly);
      currentEyelids.left  = smoothPoly(currentEyelids.left,  leftRawPoly);

      const lerp = (a,b,t)=> a + (b-a)*t;

      // Calculate the center and radius of the iris in both eyes
      const rightCenterRaw = calculateEyeCenter(landmarks, RIGHT_IRIS_RING, RIGHT_IRIS_CENTER);
      const rightRadiusRaw = calculateEyeRadius(rightCenterRaw, landmarks, RIGHT_IRIS_RING);
      const leftCenterRaw  = calculateEyeCenter(landmarks, LEFT_IRIS_RING, LEFT_IRIS_CENTER);
      const leftRadiusRaw  = calculateEyeRadius(leftCenterRaw, landmarks, LEFT_IRIS_RING);

      // smooth per-eye center/radius/open values using REALISM.SMOOTHING 
      function smooth(prev, next){
        if (!prev) return next;
        const t = 1 - REALISM.SMOOTHING;
        return {
          center: { x: lerp(prev.center.x, next.center.x, t), y: lerp(prev.center.y, next.center.y, t) },
          radius: lerp(prev.radius, next.radius, t),
          open:   clamp01((prev.open ?? next.open ?? 0) + ((next.open ?? 0) - (prev.open ?? 0)) * t)
        };
      }

      // Correct the center position with a function that also takes into account slight tilts of the eye 
      const rightCenter = biasEyeCenter(rightCenterRaw, rightRadiusRaw, RIGHT_IRIS_RING, landmarks);
      const leftCenter = biasEyeCenter(leftCenterRaw, leftRadiusRaw, LEFT_IRIS_RING, landmarks);

      // Create the new values â€‹â€‹(for the current prime) of each eye: center, radius, opening size
      const rightNext = { center: rightCenter, radius: rightRadiusRaw, open: openR };
      const leftNext  = { center: leftCenter,  radius: leftRadiusRaw,  open: openL };

      currentEyes = {
        right: currentEyes.right ? smooth(currentEyes.right, rightNext) : rightNext,
        left:  currentEyes.left  ? smooth(currentEyes.left,  leftNext)  : leftNext
      };
    }

   
    // processes each video frame and draws eye effects
    async function processVideoFrame() {

      /*
       Explanation:
       1. returns early if not running or video not ready, otherwise draws current video frame to canvas.
       2. sends the video frame to faceMesh.send({image: video})
       (FaceMesh will call onFaceMeshResults asynchronously).
       3. reads color & alpha from UI, calculates blink gates per
       eye using smoothstep and BLINK thresholds, multiplies
       alpha by gate to fade when closing.
       4. calls paintEye for left/right if alpha>threshold and eye data present.
       5. requests next animation frame while running.
      */

      if (!running || !video.videoWidth || !video.videoHeight) {
        if (running) animationId = requestAnimationFrame(processVideoFrame);
        return;
      }

      // Preparing the canvas and drawing the video on it
      updateCanvasSize();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

      // Sending the frame to the FaceMesh model
      if (faceMesh) {
        try { await faceMesh.send({ image: video }); } catch (_) {}
      }

      // Retrieve color and transparency settings
      const alpha = parseInt(alphaInp.value, 10) / 100;
      const color = colorInp.value;

      // Check eye condition and draw them
      if (alpha > 0 && currentEyes) {

        // Calculate how long each eye is open
        const gateL = currentEyes.left  ? smoothstep(BLINK.T0, BLINK.T1, (currentEyes.left.open  ?? 0))  : 0;
        const gateR = currentEyes.right ? smoothstep(BLINK.T0, BLINK.T1, (currentEyes.right.open ?? 0)) : 0;

        // Generate customized transparency
        const alphaL = alpha * gateL;
        const alphaR = alpha * gateR;

        // Draws a color/effect on the pupil
        if (alphaL > 0.01 && currentEyes.left ){
         paintEye(currentEyes.left.center,  currentEyes.left.radius,  color, alphaL, blendMode);
        }

        if (alphaR > 0.01 && currentEyes.right ){
          paintEye(currentEyes.right.center, currentEyes.right.radius, color, alphaR, blendMode);
        }

        // BUG - this is for the bug when the hand in front of eye doesn't remove color filter 

        // if (alphaL > 0.01 && currentEyes.left && leftIrisDetected){
        //  paintEye(currentEyes.left.center,  currentEyes.left.radius,  color, alphaL, blendMode);
        // }
        
        // if (alphaR > 0.01 && currentEyes.right && rightIrisDetected){
        //   paintEye(currentEyes.right.center, currentEyes.right.radius, color, alphaR, blendMode);
        // }
        // debug_drawEyelids(ctx, currentEyes, currentEyelids)

      }

      if (running) animationId = requestAnimationFrame(processVideoFrame);

      
    }

    // Loads and prepares the face recognition model
    async function initializeFaceMesh() {
      /*
        Explanation:
        1. verifies FaceMesh exists, creates new FaceMesh with
        locateFile pointing to CDN, sets options (maxNumFaces,
        refineLandmarks, confidence thresholds), attaches
        onResults handler, and initialize if available.
        2. returns true if successful, otherwise sets error status.
      */
     
      try {
        setLoadingStatus('×××ª×—×œ ×–×™×”×•×™ ×¤× ×™×');

        // If the directory does not exist, throws an error
        if (typeof FaceMesh === 'undefined') throw new Error('MediaPipe FaceMesh ×œ× × ×˜×¢×Ÿ');

        // Creates FaceMesh, and tells it where to load the necessary files (CDN)
        faceMesh = new FaceMesh({
          locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
        });

        faceMesh.setOptions({
          maxNumFaces: 1, // Recognizes the face of one person
          refineLandmarks: true, // Higher accuracy (including pupils and lips)
          minDetectionConfidence: 0.5, // Minimum confidence threshold for detection
          minTrackingConfidence: 0.5 // Minimum confidence threshold for face tracking
        });

        faceMesh.onResults(onFaceMeshResults);
        if (typeof faceMesh.initialize === 'function') await faceMesh.initialize();

        return true;
      } catch (error) {
        setStatus('×©×’×™××” ×‘××ª×—×•×œ ×–×™×”×•×™ ×¤× ×™×: ' + (error.message || error), false);
        return false;
      }
    }

    async function startCamera() {
      /*
        Explanation:
        1. checks secure context and getUserMedia support,
        2. calls getUserMedia with ideal width/height/framerate, facingMode: 'user',
        3. attaches stream to video, awaits video.ready, calls initialize FaceMesh, sets running = true, updates UI classes and buttons, starts processVideoFrame loop.
        4. error handling: stops tracks and reports messages.
      */

      try {
        // Security testing and support
        if (!isSecureContext()) { setStatus('×“×¨×•×© HTTPS ××• localhost ×œ×’×™×©×” ×œ××¦×œ××”', false); return; }
        if (!navigator.mediaDevices?.getUserMedia) { setStatus('×”×“×¤×“×¤×Ÿ ×œ× ×ª×•××š ×‘×’×™×©×” ×œ××¦×œ××”', false); return; }

        // Update status and prepare buttons
        btnStartCenter.disabled = true;
        setLoadingStatus('××‘×§×© ×’×™×©×” ×œ××¦×œ××”');

        // Request access to the camera
        stream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: 'user', // Front camera (selfie)
            aspectRatio: 9 / 16,
            width:  { ideal: 670, max: 720 },
            height: { ideal: 700, max: 1280 },
            frameRate: { ideal: 30, max: 60 }
          },
          audio: false
        }
      );

        // Connecting the video to the browser
        video.srcObject = stream;
        await new Promise((resolve, reject) => {
          video.onloadedmetadata = resolve;
          video.onerror = reject;
          setTimeout(() => reject(new Error('Timeout loading video')), 10000);
        });
        await video.play();

        // Make sure the video is loaded and the camera is working
        const ok = await initializeFaceMesh();
        if (!ok) throw new Error('Failed to initialize FaceMesh');

        running = true;

        // Show that the camera is working
        wrapEl.classList.add('camera-running');
        btnStop.disabled = false;
        resetBrightBoost()

        setStatus('×”××¦×œ××” ×¤×•×¢×œ×ª - ×–×™×”×•×™ ×¤× ×™× ×¤×¢×™×œ', true);
        processVideoFrame();

      } catch (error) {
        let msg = '×©×’×™××” ×‘×”×¤×¢×œ×ª ×”××¦×œ××”: ';
        if (error.name === 'NotAllowedError') msg += '×”×¨×©××” × ×“×—×ª×” - ×™×© ×œ××¤×©×¨ ×’×™×©×” ×œ××¦×œ××”';
        else if (error.name === 'NotFoundError') msg += '××¦×œ××” ×œ× × ××¦××” ×‘××›×©×™×¨';
        else if (error.name === 'NotReadableError') msg += '×”××¦×œ××” ×‘×©×™××•×© ××• ×œ× ×–××™× ×”';
        else msg += (error.message || '×©×’×™××” ×œ× ×™×“×•×¢×”');

        setStatus(msg, false);
        btnStartCenter.disabled = false;
        if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }
        running = false;
      }
    }

    // Turns off the camera, stops drawing loops, clears the canvas and UI
    function stopCamera() {
      // Explanation:
      // 1. stops loop, stops stream tracks, clears video.srcObject, resets currentEyes and canvas, updates UI and status.

      try {
        running = false; // Indicates that the system is no longer running
        if (animationId) { cancelAnimationFrame(animationId); animationId = null; }
        if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }
        video.srcObject = null; // Clears the video source
        currentEyes = { right: null, left: null }; // Resets eye information (no longer recognized)
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Removes classics indicating that the camera is active or the palette is open
        wrapEl.classList.remove('camera-running');
        wrapEl.classList.remove('palette-open');
        btnStartCenter.disabled = false;
        btnStop.disabled = true;
        
        setStatus('×œ×—×¥ ×¢×œ "×”×¤×¢×œ ××¦×œ××”" ×œ×”×ª×—×œ×”');

        resetBrightBoost();
      } catch (_) {}
    }


   // UI bindings:

   // Buttons: btnStartCenter -> startCamera, btnStop -> stopCamera.
   // colorInp input -> updates palette background and tag, removes active chips.
   // chips click -> sets colorInp, activates chip, closes palette.
   // alphaInp input -> updates displayed alpha value.
   // btnCapture -> snapshotAndDownload: exports canvas to PNG and triggers download.


    btnStartCenter.addEventListener('click', startCamera); 
    btnStop.addEventListener('click', stopCamera);
    colorInp.addEventListener('input', () => {
      document.querySelectorAll('.efw-chip').forEach(c => c.classList.remove('active'));
      setWrapBgFromColor(colorInp.value);
      updateColorTag();
    });


document.querySelectorAll('.efw-chip').forEach(chip => {
  chip.addEventListener('click', () => {
    document.querySelectorAll('.efw-chip').forEach(c => c.classList.remove('active'))
    chip.classList.add('active')

    const val = chip.dataset.color

    if (val === 'none') {
      if (prevAlphaBeforeNone === null) prevAlphaBeforeNone = alphaInp.value
      alphaInp.value = 0
      updateColorTag()
      resetBrightBoost()
      return
    }

    // if we were on "none", restore previous alpha (optional)
    if (prevAlphaBeforeNone !== null) {
      alphaInp.value = prevAlphaBeforeNone
      prevAlphaBeforeNone = null
    }

    colorInp.value = val
    setWrapBgFromColor(colorInp.value)
    updateColorTag()
    resetBrightBoost()

    if (wrapEl && fabBtn && pal){
      wrapEl.classList.remove('palette-open')
      fabBtn.setAttribute('aria-expanded','false')
      pal.setAttribute('aria-hidden','true')
    }
  })
})
    // document.querySelectorAll('.efw-chip').forEach(chip => {
    //   chip.addEventListener('click', () => {
    //     colorInp.value = chip.dataset.color;
    //     document.querySelectorAll('.efw-chip').forEach(c => c.classList.remove('active'));
    //     chip.classList.add('active');
    //     setWrapBgFromColor(colorInp.value);
    //     updateColorTag();

    //     // Reset the brightBoost
    //     resetBrightBoost()

    //     // Automatically close the panel after selecting a color
    //     if (wrapEl && fabBtn && pal){
    //       wrapEl.classList.remove('palette-open');
    //       fabBtn.setAttribute('aria-expanded','false');
    //       pal.setAttribute('aria-hidden','true');
    //     }
    //   });
    // });
    
    // Handle intensity select dropdown
    if (intensitySelect) {
      intensitySelect.addEventListener('change', () => {
        const value = intensitySelect.value;
        
        if (value) {
          alphaInp.value = value;
      
        const brightnessPercent = alphaInp.value / 100
        const brightColor = brightenHex(colorInp.value, brightnessPercent); 
        brightnessControlEl.style.backgroundColor = brightColor;
        }
      });
    }

function updateBrightnessUI() {
    const brightnessPercent = parseInt(alphaInp.value, 10) / 100
    const brightColor = brightenHex(colorInp.value, brightnessPercent)
    brightnessControlEl.style.backgroundColor = brightColor
}

function resetBrightBoost() {
    isBrightBoostOn = false
    // if (brightBoostBtn) brightBoostBtn.classList.remove('is-used')
}

if (brightBoostBtn) {
    brightBoostBtn.addEventListener('click', () => {
        const currentAlpha = parseInt(alphaInp.value, 10) || 0

        if (!isBrightBoostOn) {
            // turn ON
            alphaInp.value = Math.min(100, currentAlpha + BRIGHT_BOOST_STEP)
            isBrightBoostOn = true
            // brightBoostBtn.classList.add('is-used')
        } else {
            // turn OFF (revert)
            alphaInp.value = Math.max(0, currentAlpha - BRIGHT_BOOST_STEP)
            isBrightBoostOn = false
            // brightBoostBtn.classList.remove('is-used')
        }

        updateBrightnessUI()
    })
}
    
    //  Start updated UI 
  
    function snapshotAndDownload(){
      try{
        const pad = (n)=> String(n).padStart(2,'0');
        const d = new Date();
        const fname = `eye-filter-${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}-${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}.png`;
   
        const out = document.createElement('canvas')
        out.width = canvas.width
        out.height = canvas.height
        const octx = out.getContext('2d')

        // apply horizontal mirror (scaleX(-1))
        octx.translate(out.width, 0)
        octx.scale(-1, 1)
        octx.drawImage(canvas, 0, 0)

        const downloadBlob = (blob) => {
          if (!blob) return
          const url = URL.createObjectURL(blob)
          const a = document.createElement('a')
          a.href = url
          a.download = fname
          document.body.appendChild(a)
          a.click()
          setTimeout(() => { URL.revokeObjectURL(url); a.remove() }, 0)
        }

      if (out.toBlob) out.toBlob(downloadBlob, 'image/png')
      else {
        const url = out.toDataURL('image/png')
          const a = document.createElement('a')
          a.href = url
          a.download = fname
          document.body.appendChild(a)
          a.click()
          a.remove()
        }
        } catch (err) {
          setStatus('×©×’×™××” ×‘×¦×™×œ×•×/×”×•×¨×“×”', false)
        }
         }
    if (btnCapture){ btnCapture.addEventListener('click', snapshotAndDownload); }
 //  End updated UI  

  })();
</script>
</div>
</body>
</html>
